name: Sync Yandex Disk to PR

on:
  schedule:
    - cron: '0 17 * * *'
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

env:
  PUBLIC_URL: https://disk.yandex.ru/d/N2xaJZWo-hhFYw
  PUBLIC_PATH: ""
  TARGET_NAME: "First Principles Framework — Core Conceptual Specification (holonic).md"
  DEST_PATH: yadisk
  DEST_FILENAME: "First Principles Framework — Core Conceptual Specification (holonic).md"

jobs:
  sync:
    concurrency:
      group: sync-yadisk
      cancel-in-progress: true
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Find and download file
        run: |
          set -euo pipefail

          API_BASE="https://cloud-api.yandex.net/v1/disk/public/resources"

          echo "::notice::Listing directory contents"
          LIST_URL="$API_BASE?public_key=$(printf '%s' "$PUBLIC_URL" | jq -sRr @uri)&limit=1000"

          # Fetch directory listing with error handling
          echo "::debug::Requesting: $LIST_URL"
          LIST_RESPONSE=$(curl -sS -w "\n%{http_code}" "$LIST_URL")
          HTTP_CODE=$(echo "$LIST_RESPONSE" | tail -n1)
          LIST_JSON=$(echo "$LIST_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::API request failed with HTTP $HTTP_CODE"
            echo "::debug::Response: $LIST_JSON"
            exit 1
          fi

          # Validate and parse response structure
          echo "::debug::Response structure: $(echo "$LIST_JSON" | jq -c 'keys')"

          # Check if this is a folder with items
          if echo "$LIST_JSON" | jq -e '._embedded.items' > /dev/null 2>&1; then
            echo "::notice::Finding file: $TARGET_NAME"
            FILE_PATH=$(echo "$LIST_JSON" | jq -r --arg name "$TARGET_NAME" '
              ._embedded.items[] |
              select(.type == "file" and .name == $name) |
              .path
            ')

            if [ -z "$FILE_PATH" ]; then
              echo "::error::File not found: $TARGET_NAME"
              echo "::debug::Available files:"
              echo "$LIST_JSON" | jq -r '._embedded.items[] | select(.type == "file") | .name'
              exit 1
            fi
          # Check if the response itself is a direct file
          elif echo "$LIST_JSON" | jq -e '.type == "file"' > /dev/null 2>&1; then
            FILE_NAME=$(echo "$LIST_JSON" | jq -r '.name')
            if [ "$FILE_NAME" = "$TARGET_NAME" ]; then
              FILE_PATH=$(echo "$LIST_JSON" | jq -r '.path')
              echo "::notice::Found direct file link"
            else
              echo "::error::Direct file link name mismatch. Expected: $TARGET_NAME, Got: $FILE_NAME"
              exit 1
            fi
          # Check if it's a folder but items are at root level
          elif echo "$LIST_JSON" | jq -e '.type == "dir"' > /dev/null 2>&1; then
            echo "::error::Response is a directory but has no items in _embedded.items"
            echo "::debug::Response: $LIST_JSON"
            exit 1
          else
            echo "::error::Invalid API response structure"
            echo "::debug::Response: $LIST_JSON"
            echo "::debug::Response type: $(echo "$LIST_JSON" | jq -r '.type // "unknown"')"
            exit 1
          fi

          echo "::debug::Found file path: $FILE_PATH"

          echo "::notice::Getting download URL"
          DOWNLOAD_URL="$API_BASE/download?public_key=$(printf '%s' "$PUBLIC_URL" | jq -sRr @uri)&path=$(printf '%s' "$FILE_PATH" | jq -sRr @uri)"

          # Fetch download URL with error handling
          echo "::debug::Requesting: $DOWNLOAD_URL"
          DOWNLOAD_RESPONSE=$(curl -sS -w "\n%{http_code}" "$DOWNLOAD_URL")
          HTTP_CODE=$(echo "$DOWNLOAD_RESPONSE" | tail -n1)
          DOWNLOAD_JSON=$(echo "$DOWNLOAD_RESPONSE" | sed '$d')

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::Download URL request failed with HTTP $HTTP_CODE"
            echo "::debug::Response: $DOWNLOAD_JSON"
            exit 1
          fi

          HREF=$(echo "$DOWNLOAD_JSON" | jq -r '.href')

          if [ -z "$HREF" ] || [ "$HREF" = "null" ]; then
            echo "::error::Failed to get download URL"
            echo "::debug::Response: $DOWNLOAD_JSON"
            exit 1
          fi

          echo "::debug::Download URL: $HREF"

          echo "::notice::Downloading file to: $DEST_PATH/$DEST_FILENAME"
          mkdir -p "$DEST_PATH"

          if ! curl -sS -o "$DEST_PATH/$DEST_FILENAME" "$HREF"; then
            echo "::error::Failed to download file"
            exit 1
          fi

          SIZE=$(stat -c%s "$DEST_PATH/$DEST_FILENAME" 2>/dev/null || stat -f%z "$DEST_PATH/$DEST_FILENAME")
          echo "::notice::Downloaded $(numfmt --to=iec-i --suffix=B $SIZE 2>/dev/null || echo "$SIZE bytes")"

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          commit-message: 'chore(sync): Yandex Disk update'
          title: 'Sync: Yandex Disk update'
          body: |
            Automated sync from Yandex Disk public share.
            - Source: ${{ env.PUBLIC_URL }} ${{ env.PUBLIC_PATH && format('(path: {0})', env.PUBLIC_PATH) }}
            - Main FPF document: https://github.com/${{ github.repository }}/blob/main/${{ env.DEST_PATH }}/${{ env.DEST_FILENAME }}
            - Agentic diff evaluation will run automatically in this PR.
          branch: sync/yadisk
          delete-branch: true
          labels: |
            sync:auto-merge
          add-paths: |
            ${ env.DEST_PATH }/${ env.DEST_FILENAME }
